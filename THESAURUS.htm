<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Thesaurus</title>

  <script type="text/javascript" src="js/WebGl.js"></script>
  <script type="text/javascript" src="js/ShaderCouleursTextures.js"></script>
  <script type="text/javascript" src="js/glMatrix-0.9.5.min.js"></script>
  <script type="text/javascript" src="js/Transformations.js"></script>
  <script type="text/javascript" src="js/Camera.js"></script>
  <script type="text/javascript" src="js/Sol.js"></script>
  <script type="text/javascript" src="js/Murs.js"></script>
  <script type="text/javascript" src="js/murs_internes.js"></script>
  <script type="text/javascript" src="js/Textures.js"></script>
  <script type="text/javascript" src="js/timer.js"></script>
  <script type="text/javascript" src="js/points.js"></script>
  <script type="text/javascript" src="js/tresor.js"></script>
  <script type="text/javascript" src="js/fleche.js"></script>
  <script type="text/javascript" src="js/Joueur.js"></script>
  <script type="text/javascript" src="js/Teleportor.js"></script>
  <script type="text/javascript" src="js/Reciever.js"></script>
  <script type="text/javascript" src="js/Transportation.js"></script>

  <script type="text/javascript" src="js/MouseControls.js"></script>



  <script type="text/javascript" src="js/Ciel.js"></script>


  <script type="text/javascript">
    // all the code goes here
    var objgl = null;
    var objProgShaders = null;
    var objScene3D = null;
    var objCycleAnimation = null;

    var OBJ3D_SOL = 0;
    var OBJ3D_MURS = 1;
    var OBJ3D_TRESOR = 2;
    var OBJ3D_FLECHE = 3;
    var OBJ3D_MURS_INTERNES = null;


    var nbrFleches = 18;
    var nbTeleporteur = 10; // Number of teleporters in the game
    var nbReciever = 2;

    var binAriel = false;
    //=====================================================
    let isMouseLocked = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    const MOUSE_SENSITIVITY = 0.2; // Adjust this value to change mouse sensitivity
    //=====================================================

    var tabImages = [
      "images/Transparent.gif",
      "images/Sol.jpg",
      "images/Mur.jpg",
      "images/teleporter.jpg",
      "images/reciever.jpg",
      "images/sky.jpg",
    ];
    var TEX_TRANSPARENT = 0;
    var TEX_SOL = 1;
    var TEX_MUR = 2;

    var TEX_TELEPORTEUR = 3;
    var TEX_RECIEVER = 4;
    var TEX_CIEL = 5;

    var tabPosJoueur;
    var tabCibleJoueur;
    var tabPosJoueurInitial;
    var tabCibleJoueurInitial;
    var tabOrientationJoueur;
    var largeurJeux = 31;


    var vueAerienne = false;


    var startTime = createDate();
    var timerLength = 400;
    setTimerMax(timerLength); // Sets the timer in secounds for the length of the game based of timerLength
    var lastSec = 0;

    setPoint(300);

    async function demarrer() {
      var objCanvas = document.getElementById("monCanvas");
      objgl = initWebGL(objCanvas); // Initialise le contexte WebGL
      objProgShaders = initShaders(objgl);
      objScene3D = await initScene3D(objgl); // Créer la scène

      initMouseControls(objCanvas);

      effacerCanevas(objgl);
      dessiner(objgl, objProgShaders, objScene3D);
      animer();
    }

    // Un cycle d'animation
    function animer() {
      // Requête pour le prochain cycle
      objCycleAnimation = requestAnimationFrame(animer);

      // Le cycle d'animation
      effacerCanevas(objgl);
      mettreAjourAnimation();
      dessiner(objgl, objProgShaders, objScene3D);
    }

    // Pour mettre à jour l'animation
    async function mettreAjourAnimation() {
      var time = createDate();
      currentSec = nextSecond(time, startTime);
      showTime();

      if (binAriel) {
        if (lastSec != currentSec) {
          updatePoint(false, 10);
          lastSec = currentSec;
        }
      }

      showPoints();
      startTime = time;

      if (timeOut()) {
       // console.log('Reset game elements (not full scene)');
        await resetNiveau();
        updatePoint(false, 200);
      }

      animationFleche();
    }

    function animationFleche() {
      // Animation de hovering
      const hoverAmplitude = 0.1; // Hauteur maximum de amplitude
      const hoverVitesse = 1; // Vitesse of du hovering 
      const hoverOffset = Math.sin(Date.now() / 1000 * hoverVitesse) * hoverAmplitude;

      for (let i = 0; i < objScene3D.tabObjets3D.length; i++) {
        const obj3D = objScene3D.tabObjets3D[i];
        if (obj3D.baseY !== undefined) {
          setPositionY(obj3D.baseY + hoverOffset, obj3D.transformations);
        }
      }
    }

    async function initScene3D(objgl) {
      var objScene3D = new Object();
      var tabObjets3D = new Array();

      // Mettre les textures dans la scène
      objScene3D.textures = await creerTextures(objgl, tabImages);

      // Créer le sol
      var obj3DSol = creerObj3DSol(objgl, TEX_SOL);
      tabObjets3D.push(obj3DSol);

      // Créer les murs
      var obj3DMurs = creerObj3DMurs(objgl, obj3DSol, TEX_MUR);
      tabObjets3D.push(obj3DMurs);

      // Creer le tresor
      var obj3DTresor = creerobj3DTresor(objgl, obj3DMurs, TEX_TRANSPARENT);
      tabObjets3D.push(obj3DTresor);


      // Creer les fleches
      tresorZ = getPositionZ(tabObjets3D[OBJ3D_TRESOR].transformations);
      tresorX = getPositionX(tabObjets3D[OBJ3D_TRESOR].transformations);
      for (let i = 0; i < nbrFleches; i++) {
        var obj3DFleche = creerobj3DFleche(objgl, tresorZ, tresorX);
        tabObjets3D.push(obj3DFleche);
      }


      //creer teleporteurs
      for (let i = 0; i < nbTeleporteur; i++) {
        var obj3DTeleporteurs = creerObj3DTeleporteur(objgl, TEX_TELEPORTEUR, nbTeleporteur);
        tabObjets3D.push(obj3DTeleporteurs);
      }

      //creer recievers
      for (let i = 0; i < nbReciever; i++) {
        var obj3DRecievers = creerObj3DReciever(objgl, TEX_RECIEVER, nbReciever);
        tabObjets3D.push(obj3DRecievers);
      }

      // Créer le ciel
      var obj3DCiel = creerObj3DCiel(objgl, obj3DMurs, TEX_CIEL);
      tabObjets3D.push(obj3DCiel);

      var obj3DMurInterne = creerObj3DMursInternes(objgl, TEX_MUR);
      tabObjets3D.push(obj3DMurInterne);
      tabObjets3D.transformations = creerTransformations();
      OBJ3D_MURS_INTERNES = tabObjets3D.length - 1;

      // Mettre les objets 3D sur la scène
      objScene3D.tabObjets3D = tabObjets3D;

      // La caméra
      var camera = creerCamera();
      setPositionsCameraXYZ(
        [obj3DMurs.fltProfondeur / 2, 0.5, obj3DMurs.fltProfondeur / 2],
        camera
      ); // midle of the map
      setCiblesCameraXYZ([0, 0.5, 0], camera);
      setOrientationsXYZ([0, 1, 0], camera);
      objScene3D.camera = camera;

      return objScene3D;
    }

    function dessiner(objgl, objProgShaders, objScene3D) {
      // La vue
      objgl.viewport(0, 0, objgl.drawingBufferWidth, objgl.drawingBufferHeight);

      // Matrice de projection
      var matProjection = mat4.create();
      var fltRapportCanevas = objgl.drawingBufferWidth / objgl.drawingBufferHeight;
      mat4.perspective(45, fltRapportCanevas, 0.01, 100, matProjection);

      // Relier la matrice aux shaders
      objgl.uniformMatrix4fv(objProgShaders.matProjection, false, matProjection);

      for (var i = 0; i < objScene3D.tabObjets3D.length; i++) {
        var vertex = objScene3D.tabObjets3D[i].vertex;
        var couleurs = objScene3D.tabObjets3D[i].couleurs;
        var texels = objScene3D.tabObjets3D[i].texels;
        var maillage = objScene3D.tabObjets3D[i].maillage;
        var transformations = objScene3D.tabObjets3D[i].transformations;

        // Matrice du modèle
        var matModeleVue = mat4.create();
        mat4.identity(matModeleVue);

        // Placer la caméra sur la scène
        mat4.lookAt(
          getPositionsCameraXYZ(objScene3D.camera),
          getCiblesCameraXYZ(objScene3D.camera),
          getOrientationsXYZ(objScene3D.camera),
          matModeleVue
        );

        // Appliquer les transformations sur le modèle
        mat4.translate(matModeleVue, getPositionsXYZ(transformations));
        mat4.scale(matModeleVue, getEchellesXYZ(transformations));
        mat4.rotateX(matModeleVue, (getAngleX(transformations) * Math.PI) / 180);
        mat4.rotateY(matModeleVue, (getAngleY(transformations) * Math.PI) / 180);
        mat4.rotateZ(matModeleVue, (getAngleZ(transformations) * Math.PI) / 180);

        // Relier la matrice aux shaders
        objgl.uniformMatrix4fv(objProgShaders.matModeleVue, false, matModeleVue);

        if (maillage == null)
          // Dessiner les sous-objets
          for (var j = 0; j < vertex.length; j++) {

            // Relier les vertex aux shaders
            objgl.bindBuffer(objgl.ARRAY_BUFFER, vertex[j]);
            objgl.vertexAttribPointer(objProgShaders.posVertex, 3, objgl.FLOAT, false, 0, 0);
            var intNbVertex = objgl.getBufferParameter(objgl.ARRAY_BUFFER, objgl.BUFFER_SIZE) / 4 / 3;

            // Relier les couleurs aux shaders
            objgl.bindBuffer(objgl.ARRAY_BUFFER, couleurs[j]);
            objgl.vertexAttribPointer(
              objProgShaders.couleurVertex,
              4,
              objgl.FLOAT,
              false,
              0,
              0
            );

            // Activer la texture
            objgl.activeTexture(objgl.TEXTURE0 + texels[j].intNoTexture);
            objgl.bindTexture(
              objgl.TEXTURE_2D,
              objScene3D.textures[texels[j].intNoTexture]
            );

            // Relier les texels aux shaders
            objgl.bindBuffer(objgl.ARRAY_BUFFER, texels[j]);
            objgl.vertexAttribPointer(
              objProgShaders.posTexel,
              2,
              objgl.FLOAT,
              false,
              0,
              0
            );

            // Relier le no de texture et le taux de couleur aux shaders
            objgl.uniform1i(objProgShaders.noTexture, texels[j].intNoTexture);
            objgl.uniform1f(
              objProgShaders.pcCouleurTexel,
              texels[j].pcCouleurTexel
            );

            // Dessiner
            objgl.drawArrays(vertex[j].typeDessin, 0, intNbVertex);
          }
        else {
          // Dessiner le maillage

          // Relier les vertex aux shaders
          objgl.bindBuffer(objgl.ARRAY_BUFFER, vertex);
          objgl.vertexAttribPointer(
            objProgShaders.posVertex,
            3,
            objgl.FLOAT,
            false,
            0,
            0
          );

          // Relier les couleurs aux shaders
          objgl.bindBuffer(objgl.ARRAY_BUFFER, couleurs);
          objgl.vertexAttribPointer(
            objProgShaders.couleurVertex,
            4,
            objgl.FLOAT,
            false,
            0,
            0
          );

          // Activer la texture
          objgl.activeTexture(objgl.TEXTURE0 + texels.intNoTexture);
          objgl.bindTexture(objgl.TEXTURE_2D, objScene3D.textures[texels.intNoTexture]);

          // Relier les texels aux shaders
          objgl.bindBuffer(objgl.ARRAY_BUFFER, texels);
          objgl.vertexAttribPointer(objProgShaders.posTexel, 2, objgl.FLOAT, false, 0, 0);

          // Relier le no de texture et le taux de couleur aux shaders
          objgl.uniform1i(objProgShaders.noTexture, texels.intNoTexture);
          objgl.uniform1f(objProgShaders.pcCouleurTexel, texels.pcCouleurTexel);

          // Sélectionner le maillage qu'on va utiliser pour les triangles et les droites
          objgl.bindBuffer(objgl.ELEMENT_ARRAY_BUFFER, maillage);

          // Dessiner les triangles
          objgl.drawElements(
            objgl.TRIANGLES,
            maillage.intNbTriangles * 3,
            objgl.UNSIGNED_SHORT,
            0
          );
          // Dessiner les droites à la suite des triangles
          objgl.drawElements(
            objgl.LINES,
            maillage.intNbDroites * 2,
            objgl.UNSIGNED_SHORT,
            maillage.intNbTriangles * 2 * 3
          );
        }

      }



      if (binAriel) {
        objgl.uniform1i(objProgShaders.noTexture, 0);
        objgl.uniform1f(objProgShaders.pcCouleurTexel, 0.0);

        objgl.bindBuffer(objgl.ARRAY_BUFFER, obj3DJoueur.vertex);
        objgl.vertexAttribPointer(objProgShaders.posVertex, 3, objgl.FLOAT, false, 0, 0);
        objgl.enableVertexAttribArray(objProgShaders.posVertex);

        objgl.bindBuffer(objgl.ARRAY_BUFFER, obj3DJoueur.couleurs);
        objgl.vertexAttribPointer(objProgShaders.couleurVertex, 4, objgl.FLOAT, false, 0, 0);
        objgl.enableVertexAttribArray(objProgShaders.couleurVertex);

        objgl.drawArrays(objgl.TRIANGLES, 0, obj3DJoueur.nbrVertex);
      }

    }
    //=====================================================
    function initMouseControls(canvas) {
      // Handle clicking on canvas
      canvas.onclick = () => canvas.requestPointerLock();

      // Update mouse lock state
      document.onpointerlockchange = () => {
        isMouseLocked = document.pointerLockElement === canvas;
      };

      // Handle mouse movement
      document.onmousemove = (e) => {
        if (!isMouseLocked || binAriel) return;

        // Apply mouse movement with sensitivity
        const moveX = e.movementX * MOUSE_SENSITIVITY;
        const moveY = e.movementY * MOUSE_SENSITIVITY;

        rotateCameraView(moveX, moveY);
      };
    }

    function rotateCameraView(deltaX, deltaY) {
      const camera = objScene3D.camera;

      // Horizontal rotation (left/right)
      const fltX = getCibleCameraX(camera) - getPositionCameraX(camera);
      const fltZ = getCibleCameraZ(camera) - getPositionCameraZ(camera);
      const fltAngleH = (deltaX * Math.PI) / 180;

      // Calculate new horizontal look target
      const fltXPrime = fltX * Math.cos(fltAngleH) - fltZ * Math.sin(fltAngleH);
      const fltZPrime = fltX * Math.sin(fltAngleH) + fltZ * Math.cos(fltAngleH);

      // Apply horizontal rotation
      setCibleCameraX(getPositionCameraX(camera) + fltXPrime, camera);
      setCibleCameraZ(getPositionCameraZ(camera) + fltZPrime, camera);

      // Vertical rotation (up/down)
      const currentY = getCibleCameraY(camera);
      const newY = currentY + (-deltaY) * 0.5;

      const minAngle = -75.0;  // -180 degrees
      const maxAngle = 75.0;   // 180 degrees

      if (newY > minAngle && newY < maxAngle) {
        setCibleCameraY(newY, camera);
      }
    }

    //=====================================================

    function effacerCanevas(objgl) {
      // Met la couleur d'effacement au noir et complétement opaque
      objgl.clearColor(0.0, 0.0, 0.0, 1.0);
      // Efface les couleurs et le buffer de profondeur.
      objgl.clear(objgl.COLOR_BUFFER_BIT | objgl.DEPTH_BUFFER_BIT);
    }

    function deplacerCamera() {

      var camera = objScene3D.camera;

      //move froint and back with W and S
      if ((event.keyCode == 83 || event.keyCode == 87) && !binAriel) {
        // Mouvement avant arriere
        var fltX = getCibleCameraX(camera) - getPositionCameraX(camera);
        var fltZ = getCibleCameraZ(camera) - getPositionCameraZ(camera);
        var fltRayon = Math.sqrt(fltX * fltX + fltZ * fltZ);
        var intDirection = event.keyCode == 87 ? 0.4 : -0.4;

        var fltXPrime = intDirection * 0.2 * Math.cos(Math.acos(fltX / fltRayon));
        var fltZPrime = intDirection * 0.2 * Math.sin(Math.asin(fltZ / fltRayon));

        // Calculer nouvelle position camera
        var fltXCamera = getPositionCameraX(camera) + fltXPrime;
        var fltZCamera = getPositionCameraZ(camera) + fltZPrime;

        // Limites du mur
        var fltLimiteOuest = -objScene3D.tabObjets3D[OBJ3D_MURS].fltLargeur / 2 + 0.1;
        var fltLimiteEst = objScene3D.tabObjets3D[OBJ3D_MURS].fltLargeur / 2 - 0.1;
        var fltLimiteNord = -objScene3D.tabObjets3D[OBJ3D_MURS].fltProfondeur / 2 + 0.1;
        var fltLimiteSud = objScene3D.tabObjets3D[OBJ3D_MURS].fltProfondeur / 2 - 0.1;
        var binAucuneCollision = (fltXCamera > fltLimiteOuest) && (fltXCamera < fltLimiteEst) &&
          (fltZCamera > fltLimiteNord) && (fltZCamera < fltLimiteSud);

        // Checker nouvelles collisions avant de bouger
        setPositionCameraX(fltXCamera, camera);
        setPositionCameraZ(fltZCamera, camera);

        if (cameraDansMur(camera)) {
          // Ne pas faire le mouvement si il y une collision
          setPositionCameraX(getPositionCameraX(camera) - fltXPrime, camera);
          setPositionCameraZ(getPositionCameraZ(camera) - fltZPrime, camera);
        } else {
          // Update la target de la camera
          setCibleCameraX(getCibleCameraX(camera) + fltXPrime, camera);
          setCibleCameraZ(getCibleCameraZ(camera) + fltZPrime, camera);
        }
      }




        if (collisionTresor(camera)) {
          prochainNiveau();
        }





      if (collisionTeleporteur(camera)) {
        console.log("teleport!");
      }

      if (event.keyCode == 33 && !binAriel) //page up mode aerienne
      {
        tabPosJoueurInitial = getPositionsCameraXYZ(camera);
        tabCibleJoueurInitial = getCiblesCameraXYZ(camera);
        tabPosJoueur = getPositionsCameraXYZ(camera);
        tabCibleJoueur = getCiblesCameraXYZ(camera);
        setPositionsCameraXYZ([15, 40, 15], camera);
        setOrientationX(-90, camera);
        setCiblesCameraXYZ([15, 0, 15], camera);
        updateHauteurCiel(-2, obj3DCiel);
        
        console.log("page up mode aerienne");
        binAriel = true;

        obj3DJoueur = creerObj3DJoueurFleche(objgl, tabPosJoueur, tabCibleJoueur);

      }

      if (event.keyCode == 34 && binAriel) // page down mode joueur
      {
        setPositionsCameraXYZ(tabPosJoueurInitial, camera);
        setCiblesCameraXYZ(tabCibleJoueurInitial, camera);
        setOrientationX(0, camera);

        updateHauteurCiel(2, obj3DCiel);
        console.log("page down mode joueur");

        binAriel = false;
      }

      if (event.keyCode == 32) {
        var posX = Math.floor(getPositionCameraX(camera));
        var posZ = Math.floor(getPositionCameraZ(camera));
        var cibleX = Math.floor(getCibleCameraX(camera));
        var cibleZ = Math.floor(getCibleCameraZ(camera));

        var dirX = cibleX - posX;
        var dirZ = cibleZ - posZ;
        console.log("dirX: " + dirX + " dirZ: " + dirZ) 

        // directions (up, down, left, right) in grid
        var dirGridX = Math.round(dirX / Math.max(Math.abs(dirX), Math.abs(dirZ)));
        var dirGrixZ = Math.round(dirZ / Math.max(Math.abs(dirX), Math.abs(dirZ)));
        console.log("stepX: " + dirGridX + " stepZ: " + dirGrixZ) 

        var gridX = posX + dirGridX;
        var gridZ = posZ + dirGrixZ;

        console.log("posX: " + posX + " posZ: " + posZ) 
        console.log("gridX: " + gridX + " gridZ: " + gridZ)

        if (tabMurs[gridZ] && tabMurs[gridX][gridZ] == 1) {
          tabMurs[gridX][gridZ] = 0;
          objScene3D.tabObjets3D[objScene3D.tabObjets3D.length - 1] = creerObj3DMursInternes(objgl, TEX_MUR);
          console.log("mur ouvert [" + gridZ + "][" + gridX + "]");
        }
      }

      effacerCanevas(objgl);
      dessiner(objgl, objProgShaders, objScene3D);
    }

    function cameraDansMur(camera) {
      // Get the camera's current position
      var cameraX = getPositionCameraX(camera);
      var cameraZ = getPositionCameraZ(camera);

      // Convert the camera's position to grid coordinates
      var gridX = Math.floor(cameraX);
      var gridZ = Math.floor(cameraZ);

      // Check if the camera is outside the bounds of the grid (outer wall collision)
      if (gridX < 0 || gridX >= tabMurs.length || gridZ < 0 || gridZ >= tabMurs[0].length) {
        return true; // Collision with the outer wall
      }

      // Check if the camera is inside an inner wall
      if (tabMurs[gridX][gridZ] === 1) {
        return true; // Collision with an inner wall
      }
      // No collision
      return false;
    }

    function collisionTresor(camera) {
      var cameraX = getPositionCameraX(camera);
      var cameraZ = getPositionCameraZ(camera);

      var tresorX = getPositionX(objScene3D.tabObjets3D[OBJ3D_TRESOR].transformations);
      var tresorZ = getPositionZ(objScene3D.tabObjets3D[OBJ3D_TRESOR].transformations);

      if (Math.floor(cameraX) == Math.floor(tresorX) && Math.floor(cameraZ) == Math.floor(tresorZ)) {
        console.log("Collision avec tresor");
        return true;
      }
    }


    async function resetNiveau() {
      console.log("reset niveau");


      // Sauvegarder un pointeur des murs internes
      var objMursInternes = objScene3D.tabObjets3D[OBJ3D_MURS_INTERNES];

      // Garder les murs et le sol
      objScene3D.tabObjets3D = objScene3D.tabObjets3D.filter((obj3D, index) => {
        return index === OBJ3D_SOL || index === OBJ3D_MURS;
      });

      // Pousser les murs internes dans la scene
      objScene3D.tabObjets3D.push(objMursInternes);

      // Updater l'objet des murs internes
      OBJ3D_MURS_INTERNES = objScene3D.tabObjets3D.length - 1;

      positionFleches = [];

      var obj3DTresor = creerobj3DTresor(objgl, objScene3D.tabObjets3D[OBJ3D_MURS], TEX_TRANSPARENT);
      objScene3D.tabObjets3D.push(obj3DTresor);

      var tresorZ = getPositionZ(obj3DTresor.transformations);
      var tresorX = getPositionX(obj3DTresor.transformations);

      for (let i = 0; i < nbrFleches; i++) {
        var obj3DFleche = creerobj3DFleche(objgl, tresorZ, tresorX);
        objScene3D.tabObjets3D.push(obj3DFleche);
      }

      for (let i = 0; i < nbTeleporteur; i++) {
        var obj3DTeleporteur = creerObj3DTeleporteur(objgl, TEX_TELEPORTEUR, nbTeleporteur);
        objScene3D.tabObjets3D.push(obj3DTeleporteur);
      }

      var camera = objScene3D.camera;
      var centerX = objScene3D.tabObjets3D[OBJ3D_MURS].fltLargeur / 2;
      var centerZ = objScene3D.tabObjets3D[OBJ3D_MURS].fltProfondeur / 2;

      setPositionsCameraXYZ([centerX, 0.5, centerZ], camera); // Reset camera position
      setCiblesCameraXYZ([centerX, 0.5, centerZ - 1], camera); // Reset camera target
      setOrientationsXYZ([0, 1, 0], camera); // Reset camera orientation

      startTime = createDate();
      resetSeconds();
      setTimerMax(timerLength);
    }



    async function prochainNiveau() {
      console.log("Prochain niveau");

      // Sauvegarder un pointeur des murs internes
      var objMursInternes = objScene3D.tabObjets3D[OBJ3D_MURS_INTERNES];

      // Garder les murs et le sol
      objScene3D.tabObjets3D = objScene3D.tabObjets3D.filter((obj3D, index) => {
        return index === OBJ3D_SOL || index === OBJ3D_MURS;
      });

      // Pousser les murs internes dans la scene
      objScene3D.tabObjets3D.push(objMursInternes);

      // Updater l'objet des murs internes
      OBJ3D_MURS_INTERNES = objScene3D.tabObjets3D.length - 1;

      // Réinitialiser les positions des flèches
      positionFleches = [];

      // Créer un nouveau trésor
      var obj3DTresor = creerobj3DTresor(objgl, objScene3D.tabObjets3D[OBJ3D_MURS], TEX_TRANSPARENT);
      objScene3D.tabObjets3D.push(obj3DTresor);

      OBJ3D_TRESOR = objScene3D.tabObjets3D.length - 1;

      // Mettre à jour les coordonnées du trésor
      var tresorZ = getPositionZ(obj3DTresor.transformations);
      var tresorX = getPositionX(obj3DTresor.transformations);

      console.log("TresorZ : " + tresorZ);
      console.log("TresorX : " + tresorX);

      // Réduire le nombre de flèches si possible
      if (nbrFleches > 0) nbrFleches -= 2;

      // Créer de nouvelles flèches
      for (let i = 0; i < nbrFleches; i++) {
        var obj3DFleche = creerobj3DFleche(objgl, tresorZ, tresorX);
        objScene3D.tabObjets3D.push(obj3DFleche);
      }

      // Créer de nouveaux téléporteurs
      for (let i = 0; i < nbTeleporteur; i++) {
        var obj3DTeleporteur = creerObj3DTeleporteur(objgl, TEX_TELEPORTEUR, nbTeleporteur);
        objScene3D.tabObjets3D.push(obj3DTeleporteur);
      }

      // Réinitialiser la caméra
      var camera = objScene3D.camera;
      var centerX = objScene3D.tabObjets3D[OBJ3D_MURS].fltLargeur / 2;
      var centerZ = objScene3D.tabObjets3D[OBJ3D_MURS].fltProfondeur / 2;

      setPositionsCameraXYZ([centerX, 0.5, centerZ], camera); // Reset camera position
      setCiblesCameraXYZ([centerX, 0.5, centerZ - 1], camera); // Reset camera target
      setOrientationsXYZ([0, 1, 0], camera); // Reset camera orientation

      // Réinitialiser le timer
      startTime = createDate();
      resetSeconds();
      setTimerMax(timerLength);

      console.log("Nombre de flèches : " + nbrFleches);
    }


    function collisionTeleporteur(camera) {
      let cameraX = Math.floor(getPositionCameraX(camera));
      let cameraZ = Math.floor(getPositionCameraZ(camera));
      let positionJoueur = { x: cameraX, z: cameraZ }
      let tabTeleporteurs = getTabTeleports();
      let tabReceveurs = getTabReceveurs();
      const randomIndex = Math.floor(Math.random() * tabReceveurs.length);

      for (let teleporter of tabTeleporteurs) {
        if (teleporter.x === positionJoueur.x && teleporter.z === positionJoueur.z) {
          setPositionsCameraXYZ([(tabReceveurs[randomIndex].x) + 0.5, 0.5, (tabReceveurs[randomIndex].z) + 0.5], camera);
        }
      }
    }



  </script>
</head>

<body onload="demarrer()">
  <canvas id="monCanvas" width="1920" height="1200" tabindex="1" onkeydown="deplacerCamera(); return false">
    Votre navigateur ne supporte pas la balise canvas
  </canvas>
  <div id="timer"></div>
  <!--temporary. just here to test visibility of timer-->
  <div id="points"></div>
  <!--temporary. just here to test visibility of points-->
</body>

</html>